---
typora-copy-images-to: ..\JavaNote\images
---









## 问答平台

以知乎平台为原型，基于Springboot的Java web项目，使用python爬取数据填充数据库，数据库使用了Redis和MySQL。实现了用户登录注册，首页按照关注热度排序，问题以及消息的发布，用户评论。

用到的redis

1. 点赞点踩list
2. 关注与被关注：zset



本人主要负责的模块：

### 用户登录注册

客户端访问服务器，带着一个token，服务器通过一个拦截器，在你访问任何资源之前，拿token去取用户id；如果能取到，就把这信息放到hostHolder里面去，保证后面的处理也能用到这些信息；

### 异步消息队列实现登录异常时的邮件通知；

先进先出

生产者和消费者
lpush 

brpop:

用户点了赞，后续的操作都由LikeHandler来处理；

用户点赞后，我们生产一个用户点赞的事件，生产者把事件序列化存入到redis的队列中。用户点赞结束了。

后端有一个消费者那里，一直进行查找该redis构建的队列中是否有Event业务，这里是用的是redis集合类型中的brpop当给定列表内没有任何元素可供弹出的时候，连接将被 BRPOP 命令阻塞，直到等待超时或发现可弹出元素为止，然后在业务中找到点赞的业务，那么它就去找到点赞的handler进行处理，点赞的handler生成一个站内信通知这条评论的用户，有人给你点了赞了。



redis 中的lpush 和lpop功能，

### 点赞点踩

我们将所有的key定义在了一个类中，只要要用这个key，我们只需去该类中调相应的方法，而且所有的key必须有个统一的前缀，这样不会乱，所以我们将redis的key的前缀定义了一个工具类，在该类中只要传入响应的,就可以完成生产一个key。

用户在页面点赞，会向后台发送ajax请求，执行相应的方法。这里主要利用了redis中的集合，将评论和评论id设置为key。用户id放到value中，

**业务实现**

1. like：用户点击like，先将是哪个用户点的赞放到响应type（比如评论）中，如果该用户点过dislike，取消踩，也就是说用户点赞和点踩的业务不能同时出现，统计出有多少人赞了这个评论
2. dislike：用户点击dislike，记录该用户踩了，如果用户，返回该评论的点赞数
3. getLikeStatus：获取该用户点赞还是点了踩，先用sismember中查询点赞的可以中有没有该用户，有，说明点赞返回1，再到点踩中查询该用户存在吗，存在返回-1，否则返回0
4. getLikeCount：返回当前有多少人喜欢。直接统计该key的value数目scard;

scard 直接统计响应key下的数目。

每次给评论点赞，将该用户的id放到集合中，取的时候直接统计该评论key下的数目。

### 问题的发布



### **关注/被关注服务**

首先可以关注人还可以关注问题，我们考虑将其做成一个通用的类；

关注人：

A关注B这是一个什么事件？

A是B的粉丝（follower），B是A的关注对象（followee)。

这里涉及到redis中的事务，A关注B，那么A的关注列表有B,B的粉丝列表中有A。这两件事要能同时发生。



那么该如何存取这些关注者信息呢？

考虑到使用redis中数据结构，该用哪一个？想到微博上的功能，关注者的排序功能，按照时间远近进行排序，一涉及到排序，我们立马就想到Zset这个具有排序的数据结构，有序的一个集合。

涉及到的zset的方法。`zrange byscore key min max` 这样就可以拿到

zadd

key和之前一样，利用一个工具类来专门生成key，用的时候调用即可。然后value我们可以存时间戳；



### hacker news算法

如下图所示，排序是想把一些优质的问题放到前面，让更多人看到，类似于博客园的那种，如果这个问题关注的人较多，回答数目较多，也就是热度比较多的话，我就将它放在前面。

### Hacker News

它的特点是用户只能投赞成票，

![img](D:\JavaNote\images\bg2012030701.jpg)
$$
Score=（P-1）/（T+2) ^G
$$

> P：用户投票数，-1是把自己投的过滤掉 
>
> T：单位小时。+2 防止除数太小，之所以选择2，可能是因为从原始文章出现在其他网站，到转贴至Hacker News，平均需要两个小时
>
> G:  重力加速度，分值根据时间降低速率 

![1566979388036](D:\JavaNote\images\1566979388036.png)

图一：投票数越多，score越大，就在前面，等随着时间的增长，score越来越小，慢慢的沉下去；

图二：相同投票数下，随着重力加速度的增大，让score越来越小。

该如何用呢？

可以把score扔到redis中进行排序zset

P用问题的关注数

T：单位小时；

G：建议小一点



项目中影响最深的一点是，在做问题发布的时候？后台往页面渲染的用户头像拿不到？

如何解决的？

首先定位到了模块question这个模块里面。然后在相应的执行语句中打了断点调试，结果，后台能看到数据输出了，有数据的输出，但是前台显示有问题，最后发现是在前端的用户id字段写错了。

项目难点：

排序算法。

## B2C的购物商城网站

项目后端采用Django框架，使用Pycharm工具开发。用户能够实现登录，注册，商品浏览，购买等，商家则能实现商品的管理，即增删改等操作。



### 项目架构

![1567433270852](D:/JavaNote/Toffer/%E4%B8%B4%E6%97%B6%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%E5%A4%B9/1567433270852.png)

![1567757929202](D:\JavaNote\images\1567757929202.png)

### 本人主要负责的模块包括：

#### 用户模块

用户模块主要负责用户注册和登录，以及注册邮件的激活。

**注册是怎么实现的？**

接收数据，参数校验，业务处理（查用户是否存在，激活标志位置0，发邮件），返回应答。

重点是讲出Celery异步发邮件和激活邮件信息的加密；

主要包括用户的注册和登录部分，用户注册时需要往用户邮箱发送信息。这里利用Celery进行异步处理这个发邮件信息，让用户不再等待。只有当用户点击了激活邮件后，才能登录。使用了一个celery进行异步的发邮件这样就不卡在那一直等待了。

**登录如何实现？**

利用cookie和session

1. cookie是保存在浏览器端的一个文件，k-v形式；session是保存在服务器端的k-v文件；Django默认是保存在django_session这张表里；
2. cookie不安全，别人可以通过拦截cookie或找到本地cookie,实现攻击；
3. cookie大小有限制，session大小与服务器内存大小有关
4. 浏览器第一次访问服务器，服务器端会创建一个kv形式的字典，k是随机生成的字符串，v是存储的用户信息，比如id，是否登录等。服务器向浏览器返回一个cookie，这个cookie的值就是随机字符串，当第二次访问的时候，用户拿着这个cookie去服务器中找到相应的session，如果未被销毁，name就能登录。
5. 这样浏览器端只存一个随机字符串，而没有用户的具体信息；

**celery发邮件怎么发？**

注意还是借用Django内部的mail包来发送邮件，只不过将其放到服务器中异步处理。

celery类似于一个外卖小哥，用户点击注册此时相当于点了一份外卖，也就是发出了一个任务，任务处理者就是放在服务器上启动的另一个celery。

![1567435219344](D:/JavaNote/Toffer/%E4%B8%B4%E6%97%B6%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%E5%A4%B9/1567435219344.png)

​

```
使用celery实现异步执行任务
我们将耗时任务放到后台异步执行。
不会影响用户其他操作。除了注册功能，例如上传，图形处理等等耗时的任务
```

在这里，一般激活信息它的链接都是加密的而且是规定在时间内进行激活，所以借助itsdangerous对用户的id进行加密，它里面有一个方法传入一个随机key，再传入一个过期时间。

```
TimedJSONWebSignatureSerializer
```

```
serializer  = Serializer(settings.SECRET_KEY,3600)
info = {'confirm':user.id}
token = serializer.dumps(info) #bytes类型
token = token.decode() #转为字符串
# print(token)
#发邮件,利用celery异步发邮件send_mail
# 如果my_task函数有参数，可通过delay()传递,例如 my_task(a, b), my_task.delay(10, 20)
send_register_active_email.delay(email,username,token) #发送激活信息
```

使用类视图的as_views()方法，实现同一连接下不同请求的分发；

![1567733210262](D:\JavaNote\images\1567733210262.png)

#### 购物车模块

为何用list：首先list如果存的话，cart:userId: [商品id,商品数目]，考虑到字符串的分割；但是hash的话可以轻松实现一个用户的购物车记录用户所有的浏览记录。

redis中的hash实现购物车：以用户id为key，商品id为field，商品数目为value;

格式："cart_用户id":{"商品id1":商品数目,""}

实现步骤：

先尝试获取商品id的值，如果为None，直接hset添加商品

如果不为None，则直接填完商品的数目。

> 添加：hset  cart:用户id 商品id 商品数目
>
> 增加： hincrby cart:用户id 商品id 商品数目
>
> 商品总数：hlen cart:用户id 商品id 商品数目
>
> 删除商品：hdel cart:用户id 商品id 
>
> 获取购物车所有商品： hgetall cart:用户id 商品id 

#### 订单模块

#### 订单支付的流程：

用自己的私钥换支付宝的公钥的过程。

首先创建应用，Django请求支付宝平台，需要带上一个私钥，当然在平台那段需要配置一个该私钥对应的公钥，这样支付宝才能用该公钥解密出订单信息，

处理完成后，支付宝用自己的私钥加密结果，Django这里需要有支付宝的公钥用来解密该结果。

![1567743872708](D:\JavaNote\images\1567743872708.png)

![1567743878694](D:\JavaNote\images\1567743878694.png)



用户点击付款，访问/order/pay对应的视图，视图调用支付宝的接口`alipay.trade.page.pay`，调用这个接口需要传入参数：订单id，总金额，订单标题，还有两个非必须传入的参数return_url,notify_url，支付宝平台处理完成后，会返回一个支付页面的地址，我们需要引导用户到支付页面。

用户登录支付宝，输入支付密码，点击确认支付后，支付宝去默认异步通知用户支付的结果。

开发环境中，我调用支付宝接口的`alipay.trade.query`接口来查询订单是否成功，如果成功，需要更新订单状态，待评价。

#### 订单并发处理

<https://www.cnblogs.com/shoshana-kong/p/10516404.html>

![img](D:\JavaNote\images/clip_image002-1567743855459.png)

 悲观锁

```sql
select * from df_goods_sku where id=17 for update;
```

对应的Django中的方法:

`select_for_update`：拿数据的时候加了一把锁，其他事务没锁的就阻塞在那里，直到该线程处理完了。

![img](D:\JavaNote\images/clip_image004-1567743855459.png)

悲观锁获取数据时对数据行了锁定，其他事务要想获取锁，必须等原事务结束。

![1567752298730](D:\JavaNote\images\1567752298730.png)

乐观锁

查询时不锁数据，提交更改时进行判断。

此时会出现线程1把商品库存改了，而线程2拿到的是第一次读到的内容，也就是可重读，读取不到更新线程更新后的内容，这个也叫做幻读。我们将mysql的事务级别改为读取提交。

```sql
update df_goods_sku set stock=0, sales=1 where id=17 and stock=1;
```

MySQL默认的事务隔离级别是可重复读。

![1567753258674](D:\JavaNote\images\1567753258674.png)

这里Django2.0中连接数据库是配置数据库为读已提交。

冲突比较少的时候，使用乐观锁。

冲突比较多的时候，使用悲观锁。

**互联网项目请用：读已提交(Read Commited)这个隔离级别！**

#### 用户的历史浏览记录

先尝试移除列表的商品id

然后插入到列表的左侧lpush

返回用户浏览的最新5个商品

#### 页面静态化

用户访问首页的时候，所有人看到的首页都是一样的，所以考虑到直接返回静态页面。静态页面的重新生成是管理员在后台修改了首页的数据表信息，需要重新生成。

只有管理员修改了信息，然后让它重新执行celery任务，这里采用了重写admin中的save_model方法来执行任务；通过在服务器中开一个celery的进程，检测Django发送的任务，重新生成静态页面信息。用户如何访问到该信息呢，配置nginx让用户访问nginx的80端口。

![1567738759364](D:\JavaNote\images\1567739158266.png)

#### 利用数据缓存来减少对数据库的查询次数

将缓存数据保存在redis中；

如何设置？

> 通过配置settings文件里的CACHES配置来实现的。

```python
# django的缓存
CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://192.168.214.128:6379/1",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    }
}
```

将处理计算的结果先临时保存起来，下次使用的时候可以先直接使用，如果没有这个备份的数据，重新进行计算处理。

缓存的作用：缓解压力， 保存的位置、有效期、与数据库的一致性问题



#### **项目的难点在哪里？**

记录用户的历史浏览记录。

在淘宝上我们可以看到，用户如果访问了某件商品，这样他们就会有一个记录的生成，这个记录可以以后作为兴趣推荐之类的。这里我是将用户每次访问商品详情页的时候将该用户访问的商品进行记录。

当时想的是如何存这个记录，首先考虑到用户访问很多的商品，如果放到数据库中，经常进行数据库的读写，效率慢。所以考虑到redis这种内存型数据库。

redis，redis中有5大常用的数据结构，String一般用于kv形式，zset用来处理排行榜，set集合是无序的，可以求共同好友。剩下的就是hash和list。

如果用hash:

key_history：用户id: "1,2,3"

要考虑到分割字符串，修改，比较麻烦。

所以用来list来存储：

每次从左侧插入，这样保证最新。



### 容易问到的问题

#### 业务如何说？

> 先说总体的业务流程，然后再说具体业务的实现方法及使用的技术。最后说你在系统中负责的内容。
>
> 一个B2C的购物商城网站，采用Django框架，商家可以在上面增加，删除，修改，查询商品，个人可以进行注册，登录以及下单支付等功能。
>
> 商家对商品的操作是采用Django自带的后台管理系统，个人需要注册，邮箱激活后才能进行下单和支付活动。
>
> 我在这里主要负责: 用户模块和购物车模块以及订单支付。

#### 如何判断是否登录？

> 浏览器第一次访问服务器，服务器端会创建一个kv形式的字典，也就是session，k是随机生成的字符串，v是存储的用户信息，比如id，是否登录等。服务器向浏览器返回一个cookie，这个cookie的值就是随机字符串，当第二次访问的时候，用户拿着这个cookie去服务器中找到相应的session，如果没有找到，说明是未登录状态。

#### 实现购车商品数据同步

> 用户登录状态下，把购物车商品信息添加到redis中。使用hash，hash的field：商品id，value：商品信息。

#### 支付接口如何做的

> 看图

#### Redis业务使用方式

> String(字符串): 应用数, 资讯数等, (避免了select count(*) from …)
> Hash（哈希表）:用户粉丝列表, 用户点赞列表, 用户收藏列表, 用户关注列表等。
> List（列表）：消息队列, push/sub提醒。
> SortedSet（有序集合）：热门列表, 新动态列表, TopN, 自动排序。

#### redis五种数据类型存储

String，list,hash,set,zset（问深一点可能会问道底层数据结构，以及每种数据结构常用情景）这里也可以列举一些应用场景?

> String: 数据统计的需求非常普遍，通过原子递增保持计数。例如，点赞数、收藏数、分享数等。
> zset：排行榜，排行榜按照得分进行排序。例如，展示近、 热、点击率 高、活跃度高等等条件。
> 用于存储时间戳
>
> 类似排行榜，使用redis的zset用于存储时间戳，时间会不断变化。例如，按照用户关注用户的 新动态列表。
> set：社交列表
> 社交属性相关的列表信息，例如，用户点赞列表、用户收藏列表、用户关注列表等。
> 缓存
> 缓存一些热点数据，例如，PC版本文件更新内容、资讯标签和分类信息、生日祝福寿星列表。
> 队列
>
> list中的lpop 和lpush 来实现先进先出的队列。通过list的lpop及lpush接口进行队列的写入和消费，本身性能较好能解决大部分问题。
> 会话缓存
> 使用Redis进行会话缓存。例如，将web session存放在Redis中。

#### 如果数据库的信息更改以后，那么索引库和缓存库里面的信息是怎么更新的？不可能每次都去访问数据库吧？

该问题前提是商品详情页面如果采取的是缓存商品数据这种设计的话，那么当商品信息更改以后，我们调用admin中的ModelAdmin中的save_model方法，发出任务让celery worker重新生成首页静态页。

#### 用户购买商品时，什么时候才减少库存？

提交订单，支付状态由未付款改成支付成功后，才会减少库存。**支付成功状态**来减少库存。

#### 商品修改以后，购物车里面的价格是怎么处理的？

该问题假设的情景是用户添加了一件商品，那么此时商品价格修改了。此时下订单以什么为准？该问题分为下订单前和下订单后。

一旦下了订单，那么订单中就有了该商品的金额，即使修改了商品价格，也是按照订单来支付的。
如果没有下订单，那么在下订单的时候，是按照最新修改的商品价格来计算该商品金额的。

#### 在项目中并发是怎么解决的，用到哪些技术，具体是怎么实现的，原理是什么

1. 购买高性能服务器和数据库（不能从根本上解决高并发）
2. 页面静态化处理：静态化页面效率高消耗最小，避免大量数据库访问量。
3. 图片服务器分离（基本网站都采取的策略）使用独立的图片服务器降低提供页面访问请求的服务器系统压力并且可以保证系统不会因为图片问题而崩溃，在应用服务器和图片服务器上，可以进行不同的配置优化。
4. 集群架构：增加一台服务器分担原有服务器访问和存储压力来改善负载压力。比较成熟的集群架构要保证可伸缩性。
5. 负载均衡（软件和硬件的负载，一般使用软件负载更多）可将用户浏览器访问请求分发到应用服务器集群中的任何一台服务器上，如果有更多用户，就在集群中加入更多的服务器，使用应用服务器服务器的负载压力不再成为整个网站的瓶颈。
6. 特定业务功能可以考虑使用多线程去处理
7. 缓存：减少数据库访问压力
8. 读写分离，分库分表
9. 代码优化

#### redis为什么可以做缓存？项目中使用redis的目的是什么？redis什么时候使用？

Redis是key-value形式的nosql数据库。可以快速的定位到所查找的key，并把其中的value取出来。本项目用redis主要做了

1. redis做静态页面的缓存，商品数目的缓存
2. redis用来实现购物车
3. redis用来实现用户的历史记录的访问
4. redis存储用户的会话session信息

项目中使用redis一般都是作为缓存来使用的，缓存的目的就是**为了减轻数据库的压力提高存取的效率。**

#### Redis在其中起了什么作用？

在商城系统中当并发量比较高，频繁的对数据库进行读操作的时候都需要添加缓存。例如页面中内容数据的缓存、商品数据的缓存以及用户数据的缓存等。
做商品数据的缓存时，因为商品的数据量很大，而且缓存是把数据保存到内存中，此时不可能把所有的商品数据都放到缓存中。所以需要设置商品数据缓存的有效期，当用户访问到非热点数据后，此数据放到缓存中，当缓存到期后就从缓存中删除，而且长时间不会添加到缓存。而热点数据一旦从缓存中删除会马上又添加到缓存。这样可以提高缓存的利用率，同时也减轻了数据库的压力。

#### 如果用户一直添加购物车添加商品怎么办？互联网上用户那么多，这样会对数据库造成很大压力你怎么办？

把购物车商品放入redis中，redis是可以持久化的可以永久保存，此时就算是频繁的往购物车中添加数据也没用什么问题。

#### 商品存入数据库怎么保证数据库数据安全?

1. 对用户安全管理：用户操作数据库时，必须通过数据库访问的身份认证。删除数据库中的默认用户，使用自定义的用户及高强度密码。
2. 定义视图：为不同的用户定义不同的视图，可以限制用户的访问范围。通过视图机制把需要保密的数据对无权存取这些数据的用户隐藏起来，可以对数据库提供一定程度的安全保护。实际应用中常将视图机制与授权机制结合起来使用，首先用视图机制屏蔽一部分保密数据，然后在视图上进一步进行授权。
3. 数据加密：数据加密是保护数据在存储和传递过程中不被窃取或修改的有效手段。
4. 数据库定期备份

#### 当两个客户同时买一件商品时库存只有一个了,怎么控制?

> 项目里使用了乐观锁，Django2.0中配置mysql的事务隔离级别为

#### 什么是负载均衡高可用？

nginx作为负载均衡器，所有请求都到了nginx，可见nginx处于非常重点的位置，如果nginx服务器宕机后端web服务将无法提供服务，影响严重。
为了屏蔽负载均衡服务器的宕机，需要建立一个备份机。主服务器和备份机上都运行高可用（High
Availability）监控程序，通过传送诸如“I am alive”这样的信息来监控对方的运行状况。当备份机不能在一定的时间内收到这样的信息时，它就接管主服务器的服务IP并继续提供负载均衡服务；当备份管理器又从主管理器收到“I am alive”这样的信息时，它就释放服务IP地址，这样的主服务器就开始再次提供负载均衡服务。

#### 海量数据的存储问题

如今随着互联网的发展，数据的量级也是呈指数的增长，从GB到TB到PB。对数据的各种操作也是愈加的困难，传统的关系性数据库已经无法满足快速查询与插入数据的需求。这个时候NoSQL的出现暂时解决了这一危机。它通过降低数据的安全性，减少对事务的支持，减少对复杂查询的支持，来获取性能上的提升。
但是，在有些场合NoSQL一些折衷是无法满足使用场景的，就比如有些使用场景是绝对要有事务与安全指标的。这个时候NoSQL肯定是无法满足的，所以还是需要使用关系性数据库。如果使用关系型数据库解决海量存储的问题呢？此时就需要做数据库集群，为了提高查询性能将一个数据库的数据分散到不同的数据库中存储。



#### 什么是数据库分片？

简单来说，就是指通过某种特定的条件，将我们存放在同一个数据库中的数据分散存放到多个数据库上面，以达到分散单台设备负载的效果。 数据的切分（Sharding）根据其切分规则的类型，可以分为两种切分模式。
1.一种是按照不同的表来切分到不同的数据库（主机）之上，这种切可以称之为数据的垂直切分。
2.另外一种则是根据表中的数据的逻辑关系，将同一个表中的数据按照某种条件拆分到多台数据库上面，这种切分称之为数据的水平切分。
50.当数据库分片后，数据由一个数据库分散到多个数据库中。此时系统要查询时需要切换不同的数据库进行查询，那么系统如何知道要查询的数据在哪个数据库中？当添加一条记录时要向哪个数据库中插入呢？这些问题处理起来都是非常的麻烦。

#### 电商项目中是如何解决高并发和高可用的？

> 1. 页面静态化
> 2. fastDFS图片服务器
> 3. 数据缓存服务器
> 4. 数据库集群、库表散列（数据库的各种优化、数据库的拆分）
> 5. 负载均衡

#### 数据库也可以做读写分离，为什么要使用Redis担任读呢，直接使用读写分离不就可以了吗？

数据库的读写分离的确可以解决问题，但是像Redis这种非关系型数据库比较明显的优点就是数据处理效率高，读写分离和Redis的效率相比较来说，个人感觉还是使用Redis可靠。
Redis担任读的问题，当像双11这种大量访问的情况下，Redis会不会崩溃？

这个问题我也想过，这个我们可以考虑使用Redis的集群，这样就可以解决大部分的问题。



#### SKU与SPU概念

**SPU = Standard Product Unit** (标准产品单位)

SPU 是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述 了一个产品的特性。通俗点讲，属性值、特性相同的商品就可以称为一个 SPU。 

**SKU=stock keeping unit(**库存量单位**)** 

SKU 即库存进出计量的单位，可以是以件、盒、托盘等为单位。 

SKU 是物理上不可分割的最小存货单元。在使用时要根据不同业态，不同管理模式来处理。在服装、鞋类商品中使用最多最普遍。 



SPU:iphone6

SKU:黑色 16G iphone6，白色 16G iphone6



## 微信小程序前后台开发

#### 业务如何说？

> 先说总体的业务流程，然后再说具体业务的实现方法及使用的技术。最后说你在系统中负责的内容。
>
> 小程序端：首页，用户输入单号信息，地图页面显示对应的物流信息；个人主页的物流详情页，历史物流信息的展示。
>
> 后台：做三件事，登录用户校验，接受硬件端发送的经纬度信息以及车辆id等信息；经纬度信息的存储，以及向小程序端返回实时的经纬度坐标，利用redis来对小程序端的数据请求进行更新。
>
> redis  lpush lset 



